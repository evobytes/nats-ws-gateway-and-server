name: Build and Release

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  # 1) Discover all commands under cmd/
  discover-commands:
    runs-on: ubuntu-24.04
    outputs:
      all_cmds: ${{ steps.discover.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      - id: discover
        run: |
          COMMANDS=$(ls -d cmd/*/ | xargs -n 1 basename | jq -R '{"app_name": .}' | jq -s -c .)
          echo "Discovered commands: $COMMANDS"
          echo "matrix=$COMMANDS" >> "$GITHUB_OUTPUT"

  # 2) Discover changed commands (B)
  discover-changed:
    runs-on: ubuntu-24.04
    needs: [discover-commands]
    outputs:
      changed_cmds: ${{ steps.changed.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - id: changed
        shell: bash
        run: |
          set -euo pipefail

          git fetch origin +refs/heads/main:refs/remotes/origin/main --depth=0 || true
          BASE=$(git merge-base origin/main HEAD || git rev-list --max-parents=0 HEAD)

          git diff --name-only "$BASE..HEAD" > changed.txt || true
          echo "Changed files:"; cat changed.txt || true

          if grep -E '^(go\.mod|go\.sum|internal/|pkg/)' changed.txt >/dev/null 2>&1; then
            APPS=$(ls -d cmd/*/ | xargs -n1 basename)
          else
            APPS=$(awk -F/ '/^cmd\/[^/]+\//{print $2}' changed.txt | sort -u)
          fi

          if [ -z "${APPS:-}" ]; then
            echo '[]' > matrix.json
          else
            jq -nc --argjson a "$(printf '%s\n' $APPS | jq -R . | jq -s .)" '$a | map({app_name:.})' > matrix.json
          fi
          echo "matrix=$(cat matrix.json)"
          echo "matrix=$(cat matrix.json)" >> "$GITHUB_OUTPUT"

  # 3) Build & package only changed apps (fallback to all if none changed)
  build-and-package:
    runs-on: ubuntu-24.04
    needs: [discover-commands, discover-changed]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson( (needs.discover-changed.outputs.changed_cmds != '[]' && needs.discover-changed.outputs.changed_cmds) || needs.discover-commands.outputs.all_cmds ) }}
        goos: [linux, windows]
        goarch: [amd64]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: 'stable'
          cache: true

      - name: Build ${{ matrix.command.app_name }} for ${{ matrix.goos }}-${{ matrix.goarch }}
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          APP_NAME: ${{ matrix.command.app_name }}
        run: |
          make build

      - name: Install FPM (Linux only)
        if: matrix.goos == 'linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y ruby-dev build-essential rpm
          sudo gem install --no-document fpm

      - name: Compute next version for ${{ matrix.command.app_name }}
        id: ver
        shell: bash
        run: |
          echo "cmd=${{ matrix.command.app_name }} os=${{ matrix.goos }} arch=${{ matrix.goarch }}"
          set -euo pipefail
          APP="${{ matrix.command.app_name }}"
          git fetch --tags --force --prune
          LAST=$(git tag -l "${APP}/v*" --sort=-v:refname | head -n1 || true)
          if [ -z "$LAST" ]; then
            RAW="0.0.0"; BASE=""
          else
            RAW="${LAST#${APP}/v}"; BASE="$LAST.."
          fi
          COMMITS=$(git log --pretty=%s ${BASE}HEAD -- cmd/${APP}/ internal/ pkg/ || true)
          bump="patch"
          if grep -qiE 'BREAKING CHANGE|!: ' <<<"$COMMITS" ; then bump="major"
          elif grep -qiE '^feat(\(|:)|^feature' <<<"$COMMITS" ; then bump="minor"
          elif grep -qiE '^fix(\(|:)' <<<"$COMMITS" ; then bump="patch"; fi
          IFS=. read -r MA MI PA <<<"$RAW"
          case "$bump" in
            major) MA=$((MA+1)); MI=0; PA=0;;
            minor) MI=$((MI+1)); PA=0;;
            patch) PA=$((PA+1));;
          esac
          NEXT="${MA}.${MI}.${PA}"
          echo "next=${NEXT}" >> "$GITHUB_OUTPUT"

      - name: Create Linux packages for ${{ matrix.command.app_name }} (${{ matrix.goarch }})
        if: matrix.goos == 'linux'
        env:
          APP_NAME: ${{ matrix.command.app_name }}
          GOARCH: ${{ matrix.goarch }}
          VERSION: ${{ steps.ver.outputs.next }}
        run: |
          set -euo pipefail
          echo "Packaging version: $VERSION"
          STAGING_DIR="$PWD/dist/$APP_NAME"
          mkdir -p "$STAGING_DIR/etc/$APP_NAME" "$STAGING_DIR/usr/bin" ./.build

          install -m 0755 "bin/${{ matrix.goos }}-${{ matrix.goarch }}/${{ matrix.command.app_name }}" \
             "$STAGING_DIR/usr/bin/${{ matrix.command.app_name }}"

          # Optional unit/env for DEB
          if [ -f ".github/templates/$APP_NAME.service" ]; then
            SYSUNIT_DIR=/lib/systemd/system
            mkdir -p "$STAGING_DIR$SYSUNIT_DIR"
            install -m 0644 ".github/templates/$APP_NAME.service" "$STAGING_DIR$SYSUNIT_DIR/$APP_NAME.service"
          fi

          if [ -f ".github/templates/$APP_NAME.env" ]; then
            install -m 0644 ".github/templates/$APP_NAME.env" "$STAGING_DIR/etc/$APP_NAME/config.env"
          fi

          if [ -f ".github/templates/$APP_NAME.postinst.sh" ]; then
            cp ".github/templates/$APP_NAME.postinst.sh" ./.build/postinst.sh
            chmod a+x ./.build/postinst.sh
            POSTINST="--after-install ./.build/postinst.sh"
          else
            POSTINST=""
          fi

          fpm -s dir -t deb \
            --name "$APP_NAME" \
            --version "${VERSION}" \
            --architecture "${GOARCH}" \
            --description "$APP_NAME" \
            --maintainer "Dave Bevan <dave.bevan@evobytes.co.uk>" \
            --config-files /etc/$APP_NAME/config.env \
            --url "$GITHUB_SERVER_URL/$GITHUB_REPOSITORY" \
            --license "MIT" \
            ${POSTINST} \
            -C "$STAGING_DIR" .

          # Prepare RPM unit dir only if unit exists
          if [ -f ".github/templates/$APP_NAME.service" ]; then
            SYSUNIT_DIR=/usr/lib/systemd/system
            mkdir -p "$STAGING_DIR$SYSUNIT_DIR"
            install -m 0644 ".github/templates/$APP_NAME.service" "$STAGING_DIR$SYSUNIT_DIR/$APP_NAME.service"
          fi

          RPM_ARCH="${GOARCH}"; [ "$GOARCH" = "arm64" ] && RPM_ARCH="aarch64"

          fpm -s dir -t rpm \
            --name "$APP_NAME" \
            --version "${VERSION}" \
            --iteration "1" \
            --architecture "${RPM_ARCH}" \
            --description "$APP_NAME" \
            --maintainer "Dave Bevan <dave.bevan@evobytes.co.uk>" \
            --config-files /etc/$APP_NAME/config.env \
            --url "$GITHUB_SERVER_URL/$GITHUB_REPOSITORY" \
            --license "MIT" \
            --rpm-user root --rpm-group root --rpm-os linux \
            ${POSTINST} \
            -C "$STAGING_DIR" .

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.command.app_name }}-${{ matrix.goos }}-${{ matrix.goarch }}-artifacts
          path: |
            bin/${{ matrix.goos }}-${{ matrix.goarch }}/${{ matrix.command.app_name }}*
            *.deb
            *.rpm
          overwrite: true

  # 4) Per-app tag + release: run for the SAME matrix as build-and-package
  per-app-release:
    runs-on: ubuntu-24.04
    needs: [build-and-package, discover-commands, discover-changed]
    strategy:
      fail-fast: false
      matrix:
        command: ${{ fromJson( (needs.discover-changed.outputs.changed_cmds != '[]' && needs.discover-changed.outputs.changed_cmds) || needs.discover-commands.outputs.all_cmds ) }}
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      # Recompute per-app version (same logic) so tag matches packaged version
      - name: Compute next version for ${{ matrix.command.app_name }}
        id: ver
        shell: bash
        run: |
          set -euo pipefail
          APP="${{ matrix.command.app_name }}"
          git fetch --tags --force --prune
          LAST=$(git tag -l "${APP}/v*" --sort=-v:refname | head -n1 || true)
          if [ -z "$LAST" ]; then RAW="0.0.0"; BASE=""; else RAW="${LAST#${APP}/v}"; BASE="$LAST.."; fi
          COMMITS=$(git log --pretty=%s ${BASE}HEAD -- cmd/${APP}/ internal/ pkg/ || true)
          bump="patch"
          if grep -qiE 'BREAKING CHANGE|!: ' <<<"$COMMITS" ; then bump="major"
          elif grep -qiE '^feat(\(|:)|^feature' <<<"$COMMITS" ; then bump="minor"
          elif grep -qiE '^fix(\(|:)' <<<"$COMMITS" ; then bump="patch"; fi
          IFS=. read -r MA MI PA <<<"$RAW"
          case "$bump" in
            major) MA=$((MA+1)); MI=0; PA=0;;
            minor) MI=$((MI+1)); PA=0;;
            patch) PA=$((PA+1));;
          esac
          NEXT="${MA}.${MI}.${PA}"
          TAG="${APP}/v${NEXT}"
          echo "next=${NEXT}" >> "$GITHUB_OUTPUT"
          echo "tag=${TAG}"   >> "$GITHUB_OUTPUT"

      - name: Create & push per-app tag
        env:
          TAG: ${{ steps.ver.outputs.tag }}
        run: |
          git config user.name  "github-actions"
          git config user.email "github-actions@users.noreply.github.com"
          if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
            echo "Tag ${TAG} already exists; skipping."
          else
            git tag -a "${TAG}" -m "Auto-release ${TAG}"
            git push origin "${TAG}"
          fi

      # Download only this app's artifacts (merge linux & windows zips)
      - name: Download artifacts for this app
        uses: actions/download-artifact@v4
        with:
          pattern: ${{ matrix.command.app_name }}-*-artifacts
          merge-multiple: true
          path: artifacts/

      # Sanity: show what we have for this app
      - name: List files
        run: find artifacts -type f -maxdepth 3 -printf "%P\n" | sort

      - name: Create GitHub Release for ${{ steps.ver.outputs.tag }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.ver.outputs.tag }}
          files: |
            artifacts/**/${{ matrix.command.app_name }}.exe
            artifacts/**/${{ matrix.command.app_name }}_[0-9]*.deb
            artifacts/**/${{ matrix.command.app_name }}-[0-9]*.rpm
          body: |
            Automated release for ${{ steps.ver.outputs.tag }}.

